library(regmedint)

setwd("/Users/sulailfatima/Desktop/Megasync/transgenderdata")
tg.data <- read.spss("Data_transgenderBSSImodification_dataUpdated.sav",
                     to.data.frame = T,
                     use.value.labels = TRUE,
                     trim.factor.names = F,
                     trim_values = F)
# splitting data set based on akuads value
tg.data1 <- subset(tg.data, AKUADSScore2 < 20)
tg.data2 <- subset(tg.data, AKUADSScore2 >= 20) 
# for tg.data11
## Standardized variables
## BSSI
ave.bssi1 <- mean(tg.data1$BSSIScore2)
sd.bssi1 <- sd(tg.data1$BSSIScore2)
tg.data1$stdbssi1 <- ((tg.data1$BSSIScore2 - ave.bssi1)/sd.bssi1)
## SC
ave.sc1 <- mean(tg.data1$SCTotalScore)
sd.sc1 <- sd(tg.data1$SCTotalScore)
tg.data1$stdsc1 <- ((tg.data1$SCTotalScore - ave.sc1)/sd.sc1)
## AKUADS
ave.akuads1 <- mean(tg.data1$AKUADSScore2)
sd.akuads1 <- sd(tg.data1$AKUADSScore2)
tg.data1$stdakuads1 <- ((tg.data1$AKUADSScore2 - ave.akuads1)/sd.akuads1)

# running mediator / moderator analysis after standardization of all three
# variable to scale them 
regmedint_obj1 <- regmedint(data = tg.data,
                            ## Variables
                            yvar = "BSSIScore2",
                            avar = "SCTotalScore",
                            mvar = "AKUADSScore2",
                            cvar = NULL,
                            #eventvar = "event",
                            ## Values at which effects are evaluated
                            a0 = 0,
                            a1 = 1,
                            m_cde = 15.739, # mean value of AKUADSscore 
                            # (specifies the level of the mediator at 
                            # which the four-way decomposition is computed)
                            c_cond = NULL,
                            ## Model types
                            mreg = "linear",
                            yreg = "linear",
                            ## Additional specification
                            interaction = TRUE,
                            casecontrol = FALSE)
summary(regmedint_obj1) # Note moderator value is fixed at mean (ie zero),
# following lines I will generate value of cde for various values of moderator
# by imputing values of moderator into "regmedint_obj1$myreg$est_fun()"

coef(regmedint_obj1)
## generating sequential values of moderator based on the range of moderator 
## values after standardization ie from -1.49 to 2.67 
## 
akuads_seq1 <- tg.data1$stdakuads1
# Create an empty vector to store the results (sep vectors for est and se)
seq.vector.est1 <- numeric(length(akuads_seq1))
seq.vector.se1 <- numeric(length(akuads_seq1))

# passing 'akuads_seq' vector in following loop to store series of CDEs est into
# seq.vector.est

for(i in seq_along(akuads_seq1)) {
  result.est1 <- regmedint_obj1$myreg$est_fun(
    a0=0,
    a1=1,
    m_cde = akuads_seq1[i],
    c_cond = NULL
  )
  seq.vector.est1[i]<- result.est1
}
# and into seq.vector.se
for(i in seq_along(akuads_seq1)) {
  result.se1 <- regmedint_obj1$myreg$se_fun(
    a0=0,
    a1=1,
    m_cde = akuads_seq1[i],
    c_cond = NULL
  )
  seq.vector.se1[i]<- result.se1
}
# at this point, we have two vectors of same length, seq.vector.est contains
# estimates of cde and seq.vector.se contains std errors of cde. we will put
# these into a dataframe along with standardized akuads values
vectors.cde1 <- data.frame(akuads1 = tg.data1$AKUADSScore2, cde_est1 = seq.vector.est1, cde_se1 = seq.vector.se1)
library(dplyr)
vectors.cde1 <- vectors.cde1 %>%
  mutate(lower_95ci = seq.vector.est1 - 1.96 * seq.vector.se1,
         upper_95ci = seq.vector.est1 + 1.96 * seq.vector.se1)
#View(vectors.cde1)
vectors.cde1 <-vectors.cde1[order(vectors.cde1$cde_est1),]
library(ggplot2)
ggplot(data = vectors.cde1, aes(x = akuads1, y = cde_est1)) +
  #annotate("rect",xmin=20,xmax=45,ymin=-Inf,ymax=Inf,alpha=0.4,fill="red2") +
  #geom_hline(yintercept = 0.0, linetype = "dashed", color = "green", size = 1) +
  geom_pointrange(aes(ymin = lower_95ci, ymax = upper_95ci), 
                  position=position_jitter(width=0.5, height = 0.01),
                  alpha = 0.3) +
  scale_x_continuous(limits=c(0, 20)) +
  labs(x = "AKUADS Score", y = "Conrtolled Direct Effects") +
  theme_light(base_size = 16)
###########################
###########################
# for tg.data2
## Standardized variables
## BSSI
ave.bssi2 <- mean(tg.data2$BSSIScore2)
sd.bssi2 <- sd(tg.data2$BSSIScore2)
tg.data2$stdbssi2 <- ((tg.data2$BSSIScore2 - ave.bssi2)/sd.bssi2)
## SC
ave.sc2 <- mean(tg.data2$SCTotalScore)
sd.sc2 <- sd(tg.data2$SCTotalScore)
tg.data2$stdsc2 <- ((tg.data2$SCTotalScore - ave.sc2)/sd.sc2)
## AKUADS
ave.akuads2 <- mean(tg.data2$AKUADSScore2)
sd.akuads2 <- sd(tg.data2$AKUADSScore2)
tg.data2$stdakuads2 <- ((tg.data2$AKUADSScore2 - ave.akuads2)/sd.akuads2)

# running mediator / moderator analysis after standardization of all three
# variable to scale them 
regmedint_obj2 <- regmedint(data = tg.data2,
                            ## Variables
                            yvar = "stdbssi2",
                            avar = "stdsc2",
                            mvar = "stdakuads2",
                            cvar = NULL,
                            #eventvar = "event",
                            ## Values at which effects are evaluated
                            a0 = 0,
                            a1 = 1,
                            m_cde = 0, # mean value of AKUADSscore 
                            # (specifies the level of the mediator at 
                            # which the four-way decomposition is computed)
                            c_cond = NULL,
                            ## Model types
                            mreg = "linear",
                            yreg = "linear",
                            ## Additional specification
                            interaction = TRUE,
                            casecontrol = FALSE)
summary(regmedint_obj2) # Note moderator value is fixed at mean (ie zero),
# following lines I will generate value of cde for various values of moderator
# by imputing values of moderator into "regmedint_obj1$myreg$est_fun()"

coef(regmedint_obj2)
## generating sequential values of moderator based on the range of moderator 
## values after standardization ie from -1.49 to 2.67 
## 
akuads_seq2 <- tg.data2$stdakuads2
# Create an empty vector to store the results (sep vectors for est and se)
seq.vector.est2 <- numeric(length(akuads_seq2))
seq.vector.se2 <- numeric(length(akuads_seq2))

# passing 'akuads_seq' vector in following loop to store series of CDEs est into
# seq.vector.est

for(i in seq_along(akuads_seq2)) {
  result.est2 <- regmedint_obj2$myreg$est_fun(
    a0=0,
    a1=1,
    m_cde = akuads_seq2[i],
    c_cond = NULL
  )
  seq.vector.est2[i]<- result.est2
}
# and into seq.vector.se
for(i in seq_along(akuads_seq2)) {
  result.se2 <- regmedint_obj2$myreg$se_fun(
    a0=0,
    a1=1,
    m_cde = akuads_seq2[i],
    c_cond = NULL
  )
  seq.vector.se2[i]<- result.se2
}
# at this point, we have two vectors of same length, seq.vector.est contains
# estimates of cde and seq.vector.se contains std errors of cde. we will put
# these into a dataframe along with standardized akuads values
vectors.cde2 <- data.frame(akuads2 = tg.data2$AKUADSScore2, cde_est2 = seq.vector.est2, cde_se2 = seq.vector.se2)
library(dplyr)
vectors.cde2 <- vectors.cde2 %>%
  mutate(lower_95ci = seq.vector.est2 - 1.96 * seq.vector.se2,
         upper_95ci = seq.vector.est2 + 1.96 * seq.vector.se2)
#View(vectors.cde2)
vectors.cde2 <-vectors.cde2[order(vectors.cde2$cde_est2),]
library(ggplot2)
ggplot(data = vectors.cde2, aes(x = akuads2, y = cde_est2)) +
  #annotate("rect",xmin=20,xmax=45,ymin=-Inf,ymax=Inf,alpha=0.4,fill="red2") +
  #geom_hline(yintercept = 0.0, linetype = "dashed", color = "red", size = 1) +
  geom_pointrange(aes(ymin = lower_95ci, ymax = upper_95ci), 
                  position=position_jitter(width=0.5, height = 0.01), 
                  alpha = 0.3) +
  scale_x_continuous(limits=c(18, 50)) +
  labs(x = "AKUADS Score", y = "Conrtolled Direct Effects") +
  theme_light(base_size = 16)
